<!DOCTYPE html>
<html lang="ja">
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />

	<script type="text/javascript" charset="utf-8" src="../script/Utility.js"></script>
	<script language="javascript" type="text/javascript">
		// C#側からAPI登録を実行される。
		// const wri = chrome.webview.hostObjects.sync.wri;
		// const wri_async = chrome.webview.hostObjects.wri;

		// C# -> WebView2 Event Handler
		// C#側からWebView2の初期化が完了したらJavaScriptの初期化としてコールされる
		const csLoaded = () => {
			try {
				// パラメータチェック
				const params = new URLSearchParams(document.location.search);
				const file = params.get("param1");
				// 引数が存在したら表示対象xmlとみなす
				if (file !== null) {
					// ファイル内容取得
					const content = wri.io.file.Read(file);
					if (content !== null) {
						loadXml(content, file);
					}
				}

				//
				document.addEventListener("dragover", (e) => {
					e.preventDefault();
				});
				document.addEventListener("drop", async (e) => {
					const file = await getDroppedFilePath(e);
					if (file !== null) {
						const content = wri.io.file.Read(file);
						if (content !== null) {
							loadXml(content, file);
						}
					}
				});
			} catch (msg) {
				return false;
			}
			//Utility.Log("<WebView2/JavaScript Loaded.>");
			return true;
		}
		// ↑ロジックを理解した上で変更すること↑

		const loadXml = (xml, file) => {
			// XML parse
			const parser = new DOMParser();
			const xmlDoc = parser.parseFromString(xml, "text/xml");
			// stylesheet等を解析する
			const nodes = xmlDoc.childNodes;
			// root要素は1つだけとみなす
			const children = xmlDoc.children;
			if (children.length <= 0) {
				return;
			}
			const root = children[0]
			// XML analyze
			const info = {
				has_stylesheet: false,
				stylesheet_data: null,
				count_content: 0,
				count_attr: 0,
				depth: 0,
			};
			analyzeXml(nodes, root, info);
			// html化typeを決定する
			let html_type = 0;
			if (info.count_content >= info.count_attr) {
				html_type = 0;
			} else {
				html_type = 1;
			}
			if (info.has_stylesheet) {
				html_type = 2;
			}
			// html化
			let xml_dom;
			switch (html_type) {
				case 0:
					// contentベース
					xml_dom = convertByContent(root);
					break;

				case 2:
					xml_dom = wri.io.ConvertXml2Html(file);
					document.body.innerHTML = xml_dom;
					return;

				case 1:
				default:
					// attributeベース
					xml_dom = convertByContent(root);
					break;
			}
			//
			const base_elem = document.getElementById("viewer");
			if (base_elem !== null) {
				base_elem.innerHTML = "";
				base_elem.appendChild(xml_dom);
			}
		}
		const analyzeXml = (nodes, elem, info) => {
			// nodes: NodeList
			for (let i = 0; i<nodes.length; i++) {
				const node = nodes[i];
				if (node.nodeName === "xml-stylesheet") {
					info.has_stylesheet = true;
					// type=\"text/xsl\" href=\"_.xsl\"
					info.stylesheet_data = node.data;
				}
			}
			// elem: htmlCollection
			analyzeXmlBody(elem, info);
		}
		const analyzeXmlBody = (elem, info) => {
			if (elem.children.length === 0) {
				if (elem.textContent !== "") {
					info.count_content++;
				}
				else if (elem.attributes.length > 0) {
					info.count_attr++;
				}
			} else {
				const children = elem.children;
				for (let i = 0; i<children.length; i++) {
					const node = children[i];
					analyzeXmlBody(node, info);
				}
			}
		}
		const convertByContent = (root) => {
			// root要素作成
			const table = document.createElement("table");
			const header = document.createElement("thead");
			const body = document.createElement("tbody");
			table.appendChild(header);
			table.appendChild(body);
			table.className = "xml";
			const children = root.children;
			if (children.length <= 0) {
				return;
			}
			// header
			{
				const child = children[0];
				const row = document.createElement("tr");
				convertByContentImplHeader(row, child);
				header.appendChild(row);
			}
			//
			for (let i=0; i<children.length; i++) {
				const child = children[i];
				const row = document.createElement("tr");
				convertByContentImplBody(row, child);
				body.appendChild(row);
			}
			//
			return table;
		}
		const convertByContentImplHeader = (elem, node) => {
			// node要素を追加
			{
				const item = document.createElement("th");
				item.textContent = node.tagName;
				elem.appendChild(item);
			}
			// 
			for (let i=0; i<node.children.length; i++) {
				const child = node.children[i];
				convertByContentImplHeader(elem, child);
			}
		}
		const convertByContentImplBody = (elem, node) => {
			// node要素を追加
			{
				const item = document.createElement("td");
				item.textContent = node.textContent;
				elem.appendChild(item);
			}
			// 
			for (let i=0; i<node.children.length; i++) {
				const child = node.children[i];
				convertByContentImplBody(elem, child);
			}
		}

		const debug = () => {
		}

	</script>
	<style type="text/css">
		body {
			margin: 0;
			padding: 0;
			background-color:rgb(239, 255, 213);
			display: flex;
			flex-direction: column;
			height: 100vh;
			width: 100vw;
		}

		#header {
			width: 100%;
			border-bottom: 5px solid #404040;
			background-color: #808080;
		}
		#body {
			flex: 1;
			overflow-y: auto;
			background-color: #fff;
		}

	</style>
	<link rel="stylesheet" type="text/css" href="../styles/default.css" />
</head>
<body>
<div id="header">
	<button onclick="debug()">Debug</button>
</div>
<div id="body">
	<div id="viewer"></div>
</div>
</body>
</html>
